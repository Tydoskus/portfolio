<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Territory Conquer</title>
  <style>
  :root{
    --bg:#f6f8ff;
    --panel:#ffffff;
    --panel2:#f2f5ff;
    --text:#0f172a;
    --muted:#475569;
    --line:rgba(15,23,42,.12);
    --p1:#2f7dff;
    --p2:#ff3a6e;
    --neu:#7a8699;
    --good:#16a34a;
    --warn:#f59e0b;
    --bad:#ef4444;
    --shadow: 0 10px 24px rgba(15,23,42,.10);
  }

  *{ box-sizing:border-box; }
  html,body{
    height:100%;
    margin:0;
    font-family: system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,sans-serif;
    color:var(--text);
    background:
      radial-gradient(900px 600px at 20% 10%, rgba(47,125,255,.08) 0%, rgba(47,125,255,0) 60%),
      linear-gradient(180deg, #fbfcff 0%, var(--bg) 60%, #ffffff 100%);
  }

  .wrap{
    display:grid;
    grid-template-columns: 320px 1fr;
    gap:14px;
    padding:14px;
    height:100%;
  }

  .panel{
    background: var(--panel);
    border:1px solid var(--line);
    border-radius:16px;
    box-shadow: var(--shadow);
    overflow:hidden;
  }

  .left{
    display:flex;
    flex-direction:column;
    min-width:280px;
  }

  .hdr{
    padding:14px 14px 10px;
    background: linear-gradient(180deg, rgba(15,23,42,.02), rgba(15,23,42,0));
    border-bottom:1px solid var(--line);
  }

  .title{
    font-weight:800;
    letter-spacing:.2px;
    margin:0 0 6px 0;
    font-size:18px;
    display:flex;
    align-items:center;
    gap:10px;
  }

  .dot{
    width:10px;height:10px;border-radius:999px;
    background:var(--good);
    box-shadow:0 0 0 4px rgba(22,163,74,.14);
  }

  .sub{
    color:var(--muted);
    font-size:12px;
    line-height:1.35;
  }

  .section{
    padding:12px 14px;
    border-bottom:1px solid var(--line);
  }

  .row{
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:10px;
    margin:8px 0;
    font-size:13px;
    color:var(--muted);
  }
  .row b{ color:var(--text); font-weight:700; }

  .btnrow{
    display:flex;
    gap:10px;
    margin-top:10px;
  }

  button{
    border:1px solid var(--line);
    background: rgba(15,23,42,.04);
    color:var(--text);
    padding:10px 12px;
    border-radius:12px;
    cursor:pointer;
    font-weight:700;
    letter-spacing:.1px;
    transition: transform .06s ease, background .12s ease, box-shadow .12s ease;
    user-select:none;
  }
  button:hover{
    background: rgba(15,23,42,.06);
    box-shadow: 0 6px 14px rgba(15,23,42,.08);
  }
  button:active{ transform: translateY(1px); }
  button.secondary{
    background: transparent;
  }
  button.secondary:hover{
    background: rgba(15,23,42,.04);
    box-shadow:none;
  }

  .mini{
    font-size:12px;
    color:var(--muted);
    line-height:1.4;
  }

  .control{
    display:grid;
    grid-template-columns: 1fr 120px;
    gap:10px;
    align-items:center;
    margin:10px 0 0;
  }

  input[type="range"]{ width:100%; }

  .pill{
    background: rgba(15,23,42,.04);
    border:1px solid var(--line);
    border-radius:999px;
    padding:8px 10px;
    text-align:center;
    font-weight:800;
    font-size:12px;
    color:var(--text);
    user-select:none;
  }

  .log{
    flex:1;
    overflow:auto;
    padding:12px 14px;
    background: rgba(15,23,42,.02);
  }
  .log h3{
    margin:0 0 10px 0;
    font-size:13px;
    color:var(--muted);
    letter-spacing:.1px;
  }

  .evt{
    font-size:12px;
    color:var(--muted);
    padding:8px 10px;
    border:1px solid var(--line);
    border-radius:12px;
    margin:8px 0;
    background: #ffffff;
    line-height:1.35;
  }

  .evt .tag{
    display:inline-block;
    font-weight:900;
    font-size:11px;
    padding:3px 8px;
    border-radius:999px;
    margin-right:8px;
    color:#ffffff;
  }
  .tag.p1{ background: var(--p1); }
  .tag.p2{ background: var(--p2); }
  .tag.sys{ background: var(--warn); color:#1f2937; }

  .game{
    position:relative;
    display:flex;
    flex-direction:column;
    overflow:hidden;
    background: var(--panel);
  }

  .topbar{
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:10px;
    padding:10px 12px;
    border-bottom:1px solid var(--line);
    background: rgba(255,255,255,.85);
  }

  .topbar .status{
    display:flex;
    align-items:center;
    gap:10px;
    flex-wrap:wrap;
    font-size:13px;
    color:var(--muted);
  }

  .badge{
    border:1px solid var(--line);
    background: rgba(15,23,42,.03);
    padding:6px 10px;
    border-radius:999px;
    font-weight:800;
    color:var(--text);
    font-size:12px;
  }

  .badge .sw{
    display:inline-block;
    width:10px;height:10px;
    border-radius:999px;
    margin-right:8px;
    vertical-align:-1px;
  }
  .sw.p1{ background:var(--p1); }
  .sw.p2{ background:var(--p2); }
  .sw.neu{ background:var(--neu); }

  canvas{ width:100%; height:100%; display:block; }

  .hint{
    position:absolute;
    left:12px; bottom:12px;
    padding:10px 12px;
    border-radius:14px;
    border:1px solid var(--line);
    background: rgba(255,255,255,.85);
    color:var(--muted);
    font-size:12px;
    line-height:1.35;
    max-width:min(520px, 80%);
    box-shadow: var(--shadow);
    user-select:none;
    pointer-events:none;
    backdrop-filter: blur(8px);
  }
  .hint b{ color:var(--text); }

  /* Send or defend troops button */
  .chipbtn{
    border:1px solid var(--line);
    background: rgba(15,23,42,.03);
    color: var(--text);
    padding:6px 10px;
    border-radius:999px;
    font-weight:800;
    font-size:12px;
    cursor:pointer;
    line-height:1;
  }
  .chipbtn:hover{ background: rgba(15,23,42,.06); }
  .chipbtn:active{ transform: translateY(1px); }
  .chipbtn:disabled{
    opacity:.5;
    cursor:not-allowed;
  }
	.modal{
	  position:absolute;
	  inset:0;
	  background: rgba(15,23,42,.35);
	  display:flex;
	  align-items:center;
	  justify-content:center;
	  padding:16px;
	}
	.modal.hidden{ display:none; }
	
	.modalCard{
	  width:min(520px, 92vw);
	  background: var(--panel);
	  border:1px solid var(--line);
	  border-radius:16px;
	  box-shadow: var(--shadow);
	  overflow:hidden;
	}
	
	.modalHdr{
	  display:flex;
	  align-items:center;
	  justify-content:space-between;
	  gap:12px;
	  padding:12px 14px;
	  border-bottom:1px solid var(--line);
	  background: rgba(15,23,42,.02);
	}
	
	.modalTitle{
	  font-weight:900;
	  letter-spacing:.2px;
	}
	
	.modalBody{
	  padding:12px 14px;
	  display:flex;
	  flex-direction:column;
	  gap:10px;
	}
	
	.upgRow{
	  display:flex;
	  align-items:center;
	  justify-content:space-between;
	  gap:10px;
	  border:1px solid var(--line);
	  border-radius:14px;
	  padding:10px 12px;
	  background:#fff;
	}
	
	.upgRow .lhs{
	  display:flex;
	  flex-direction:column;
	  gap:2px;
	}
	.upgRow .name{ font-weight:900; }
	.upgRow .desc{ font-size:12px; color:var(--muted); }
	
	.upgRow .rhs{
	  display:flex;
	  align-items:center;
	  gap:10px;
	}
	.upgRow .lvl{
	  font-weight:900;
	  font-size:12px;
	  padding:6px 10px;
	  border-radius:999px;
	  border:1px solid var(--line);
	  background: rgba(15,23,42,.03);
	}
	
	.modalFoot{
	  padding:10px 14px;
	  border-top:1px solid var(--line);
	  background: rgba(15,23,42,.02);
	}

  @media (max-width: 980px){
    .wrap{ grid-template-columns: 1fr; }
    .left{ order:2; }
    .game{ order:1; min-height: 60vh; }
  }
</style>

</head>

<body>
  <div class="wrap">
    <div class="panel left">
      <div class="hdr">
        <div class="title"><span class="dot"></span>Territory Conquer</div>
        <div class="sub">
          Generate troops per territory, send armies along links, capture the map.
          You are <b style="color:var(--p1)">Blue</b>. AI is <b style="color:var(--p2)">Red</b>.
        </div>

        <div class="btnrow">
          <button id="btnNew">New Game</button>
          <button id="btnPause" class="secondary">Pause</button>
        </div>

        <div class="control">
          <div class="mini">Send % from selected</div>
          <div class="pill" id="sendPctPill">50%</div>
          <input id="sendPct" type="range" min="10" max="90" value="50" />
        </div>

        <div class="control">
          <div class="mini">Game speed</div>
          <div class="pill" id="speedPill">1.0×</div>
          <input id="speed" type="range" min="50" max="200" value="100" />
        </div>
      </div>

      <div class="section">
        <div class="row"><span>Territories</span><b id="statTerr">—</b></div>
        <div class="row"><span>Blue troops</span><b id="statP1">—</b></div>
        <div class="row"><span>Red troops</span><b id="statP2">—</b></div>
        <div class="row"><span>Neutral troops</span><b id="statNeu">—</b></div>
        <div class="row"><span>Income (Blue)</span><b id="statInc1">—</b></div>
        <div class="row"><span>Income (Red)</span><b id="statInc2">—</b></div>
      </div>

      <div class="log" id="log">
        <h3>Events</h3>
      </div>
    </div>

    <div class="panel game">
      <div class="topbar">
        <div class="status">
          <span class="badge"><span class="sw p1"></span>Blue</span>
          <span class="badge"><span class="sw p2"></span>Red</span>
          <span class="badge"><span class="sw neu"></span>Neutral</span>
          <span class="badge" id="badgeSel">Selected: —</span>
          <button id="btnAuto" class="chipbtn" title="Toggle selected node auto mode">Auto: —</button>
          
        </div>
        <div class="status">
		  <span class="badge" id="badgeWave">Wave: 1</span>
		  <span class="badge" id="badgeCredits">Credits: 0</span>
		  <button id="btnRepeat" class="chipbtn" title="Replay this wave">Repeat</button>
		  <button id="btnNext" class="chipbtn" title="Advance to next wave">Next</button>
		  <button id="btnUpg" class="chipbtn" title="Upgrades">Upgrades</button>
		  <span class="badge" id="badgeWin">—</span>
		</div>
      </div>

      <canvas id="c"></canvas>
		
      <div id="upgModal" class="modal hidden">
		  <div class="modalCard">
		    <div class="modalHdr">
		      <div class="modalTitle">Upgrades</div>
		      <button id="btnUpgClose" class="chipbtn">Close</button>
		    </div>
		
		    <div class="modalBody" id="upgList"></div>
		
		    <div class="modalFoot">
		      <div class="mini">Upgrades are permanent. Credits are earned on wave end.</div>
		    </div>
		  </div>
		</div>

    </div>
  </div>

  <script>
    // Territory Conquer - single-file game
    // Core ideas:
    // - Graph of territories with links
    // - Each territory generates troops over time (owner-based; neutral slower)
    // - Player can send troops along links; travel time depends on distance
    // - Combat on arrival; capture if attackers exceed defenders
    // - Territories "level up" based on held time to increase generation
    // - AI periodically evaluates attacks and defenses

    (() => {
      /** @type {HTMLCanvasElement} */
      const canvas = document.getElementById('c');
      const ctx = canvas.getContext('2d');

      const ui = {
        btnNew: document.getElementById('btnNew'),
        btnPause: document.getElementById('btnPause'),
        sendPct: document.getElementById('sendPct'),
        sendPctPill: document.getElementById('sendPctPill'),
        speed: document.getElementById('speed'),
        speedPill: document.getElementById('speedPill'),
        statTerr: document.getElementById('statTerr'),
        statP1: document.getElementById('statP1'),
        statP2: document.getElementById('statP2'),
        statNeu: document.getElementById('statNeu'),
        statInc1: document.getElementById('statInc1'),
        statInc2: document.getElementById('statInc2'),
        badgeSel: document.getElementById('badgeSel'),
        badgeMode: document.getElementById('badgeMode'),
        badgeWin: document.getElementById('badgeWin'),
        log: document.getElementById('log'),
        btnAuto: document.getElementById('btnAuto'),
		badgeWave: document.getElementById('badgeWave'),
		badgeCredits: document.getElementById('badgeCredits'),
		btnRepeat: document.getElementById('btnRepeat'),
		btnNext: document.getElementById('btnNext'),
		btnUpg: document.getElementById('btnUpg'),
		upgModal: document.getElementById('upgModal'),
		btnUpgClose: document.getElementById('btnUpgClose'),
		upgList: document.getElementById('upgList'),
      };

      // --------- RNG (deterministic-ish if you want, currently seeded by time)
      function mulberry32(a){
        return function(){
          let t = a += 0x6D2B79F5;
          t = Math.imul(t ^ (t >>> 15), t | 1);
          t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
          return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
        };
      }
      let rand = mulberry32((Date.now() ^ (Math.random()*1e9)) >>> 0);

		// ---------- Meta (persistent incremental layer)
		const SAVE_KEY = 'territory_meta_v1';
		
		let meta = {
		  wave: 1,
		  credits: 0,
		  upgrades: { income: 0, speed: 0, defense: 0, start: 0 },
		};
		
		function loadMeta(){
		  try{
		    const raw = localStorage.getItem(SAVE_KEY);
		    if (!raw) return;
		    const obj = JSON.parse(raw);
		    if (obj && typeof obj === 'object'){
		      meta.wave = Math.max(1, obj.wave|0 || 1);
		      meta.credits = Math.max(0, Math.floor(obj.credits || 0));
		      meta.upgrades = Object.assign(meta.upgrades, obj.upgrades || {});
		    }
		  }catch(e){}
		}
		
		function saveMeta(){
		  try{ localStorage.setItem(SAVE_KEY, JSON.stringify(meta)); }catch(e){}
		}
		
		const UPGRADES = {
		  income: {
		    name: 'Blue Income',
		    desc: '+10% troop generation per level (Blue only).',
		    baseCost: 25, costMult: 1.6,
		    effect: lvl => 1 + 0.10*lvl,
		  },
		  speed: {
		    name: 'March Speed',
		    desc: '+8% march speed per level (Blue marches only).',
		    baseCost: 35, costMult: 1.7,
		    effect: lvl => 1 + 0.08*lvl,
		  },
		  defense: {
		    name: 'Blue Defense',
		    desc: '+0.02 defender advantage per level (Blue-held nodes).',
		    baseCost: 45, costMult: 1.8,
		    effect: lvl => 0.02*lvl,
		  },
		  start: {
		    name: 'Start Troops',
		    desc: '+6 starting troops per level on your first territory.',
		    baseCost: 40, costMult: 1.75,
		    effect: lvl => 6*lvl,
		  },
		};
		
		function upgradeCost(key){
		  const def = UPGRADES[key];
		  const lvl = meta.upgrades[key] | 0;
		  return Math.floor(def.baseCost * Math.pow(def.costMult, lvl));
		}
		
		function renderUpgrades(){
		  ui.upgList.innerHTML = '';
		  for (const key of Object.keys(UPGRADES)){
		    const def = UPGRADES[key];
		    const lvl = meta.upgrades[key] | 0;
		    const cost = upgradeCost(key);
		
		    const row = document.createElement('div');
		    row.className = 'upgRow';
		
		    const lhs = document.createElement('div');
		    lhs.className = 'lhs';
		
		    const nm = document.createElement('div');
		    nm.className = 'name';
		    nm.textContent = def.name;
		
		    const ds = document.createElement('div');
		    ds.className = 'desc';
		    ds.textContent = def.desc;
		
		    lhs.appendChild(nm);
		    lhs.appendChild(ds);
		
		    const rhs = document.createElement('div');
		    rhs.className = 'rhs';
		
		    const pill = document.createElement('div');
		    pill.className = 'lvl';
		    pill.textContent = `Lv ${lvl}`;
		
		    const btn = document.createElement('button');
		    btn.className = 'chipbtn';
		    btn.textContent = `Buy (${cost})`;
		    btn.disabled = meta.credits < cost;
		    btn.addEventListener('click', () => {
		      const c = upgradeCost(key);
		      if (meta.credits < c) return;
		      meta.credits -= c;
		      meta.upgrades[key] = (meta.upgrades[key] | 0) + 1;
		      saveMeta();
		      refreshMetaUI();
		      renderUpgrades();
		      logEvent(null, `${def.name} upgraded to Lv ${meta.upgrades[key]}.`);
		    });
		
		    rhs.appendChild(pill);
		    rhs.appendChild(btn);
		
		    row.appendChild(lhs);
		    row.appendChild(rhs);
		    ui.upgList.appendChild(row);
		  }
		}
		
		function refreshMetaUI(){
		  ui.badgeWave.textContent = `Wave: ${meta.wave}`;
		  ui.badgeCredits.textContent = `Credits: ${fmt(meta.credits)}`;
		}
		
		// ---------- Run state
		let run = {
		  seed: (Date.now() >>> 0),
		  wave: 1,
		  ended: false,
		  seconds: 0,
		  captured: 0,
		  scale: null,
		  mods: null,
		};
		
		function waveScale(wave){
		  const w = Math.max(1, wave|0);
		  return {
		    redGenMult: 1 + 0.15*(w-1),
		    redStartTroopsMult: 1 + 0.20*(w-1),
		    aiThinkEvery: Math.max(0.55, AI.thinkEvery - 0.02*(w-1)),
		    aiSafeMarginMult: 1 + 0.02*(w-1),
		  };
		}
		
		function computeMods(){
		  return {
		    incomeMult: UPGRADES.income.effect(meta.upgrades.income|0),
		    speedMult: UPGRADES.speed.effect(meta.upgrades.speed|0),
		    defBonus: UPGRADES.defense.effect(meta.upgrades.defense|0),
		    startBonus: UPGRADES.start.effect(meta.upgrades.start|0),
		  };
		}
		
		function startRun({ wave, seed }){
		  run.wave = wave;
		  run.seed = (seed >>> 0);
		  run.ended = false;
		  run.seconds = 0;
		  run.captured = 0;
		  run.scale = waveScale(run.wave);
		  run.mods = computeMods();
		
		  rand = mulberry32(run.seed);
		  newGame();              // uses current rand
		  refreshMetaUI();
		  computeStats();
		}
		
		function awardCredits(result){
		  // simple economy: scale with wave; reward both wins and attempts
		  const w = run.wave;
		  const timeBonus = Math.floor(run.seconds / 30) * (2 + Math.floor(w/3)); // every 30s
		  const capBonus = run.captured * (3 + Math.floor(w/4));
		  const winBonus = (result === 'win') ? (25 * w) : 0;
		
		  const gain = Math.max(0, timeBonus + capBonus + winBonus);
		  meta.credits += gain;
		  saveMeta();
		  refreshMetaUI();
		  logEvent(null, `Run ended: ${result.toUpperCase()} • +${gain} credits.`);
		}
		
		function endRun(result){
		  if (run.ended) return;
		  run.ended = true;
		  awardCredits(result);
		}

      // --------- Game constants
      const OWNER = { NEU: 0, P1: 1, P2: 2 };
      const COLORS = {
        bg1: '#0b1020',
        p1: getComputedStyle(document.documentElement).getPropertyValue('--p1').trim() || '#4aa3ff',
        p2: getComputedStyle(document.documentElement).getPropertyValue('--p2').trim() || '#ff4a6b',
        neu: getComputedStyle(document.documentElement).getPropertyValue('--neu').trim() || '#9aa6c7',
        line: 'rgba(255,255,255,.12)',
        text: 'rgba(231,236,255,.95)',
        muted: 'rgba(169,179,214,.9)',
      };

      // Generation & combat
      const GEN = {
        basePlayer: 0.95,      // troops/sec at level 1
        baseNeutral: 0.35,     // troops/sec
        levelBonus: 0.22,      // + per level
        maxLevel: 7,
        levelUpEvery: 18.0,    // seconds held -> next level
      };

      const COMBAT = {
        defenderAdvantage: 1.10, // small edge for defenders
        captureFloor: 1.0,       // min troops remain when captured
      };

      const MOVE = {
        speed: 140,             // px/sec
        minSend: 1,
      };

      const AI = {
        thinkEvery: 0.8,        // seconds
        aggressiveness: 0.72,    // higher -> more attacks
        reserveFrac: 0.35,       // keep fraction at source
        safeMargin: 1.2,        // attack only if (attackers > defenders * margin)
        opportunism: 0.35,       // chance to snipe weak neighbor
      };

      // --------- Game state
      let W = 0, H = 0, DPR = 1;
      let paused = false;
      let timeScale = 1.0;

      /** @type {{id:number,x:number,y:number,owner:number,troops:number,level:number,heldTime:number,links:number[]}[]} */
      let nodes = [];
      /** @type {{from:number,to:number,owner:number,amount:number,progress:number,dist:number,fx:number,fy:number,tx:number,ty:number}[]} */
      let marches = [];

      let selected = -1;
      let dragging = false;
      let dragPos = {x:0,y:0};
      let lastT = performance.now();

      function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
      function lerp(a,b,t){ return a + (b-a)*t; }
      function dist(ax,ay,bx,by){ const dx=ax-bx, dy=ay-by; return Math.hypot(dx,dy); }

      function fmt(n){
        if (n >= 1e9) return (n/1e9).toFixed(2)+'B';
        if (n >= 1e6) return (n/1e6).toFixed(2)+'M';
        if (n >= 1e3) return (n/1e3).toFixed(2)+'K';
        return Math.floor(n).toString();
      }

      function ownerName(o){
        if (o === OWNER.P1) return 'Blue';
        if (o === OWNER.P2) return 'Red';
        return 'Neutral';
      }

      function ownerColor(o){
        if (o === OWNER.P1) return COLORS.p1;
        if (o === OWNER.P2) return COLORS.p2;
        return COLORS.neu;
      }

      function logEvent(tag, text){
        const div = document.createElement('div');
        div.className = 'evt';
        const span = document.createElement('span');
        span.className = 'tag ' + (tag === OWNER.P1 ? 'p1' : tag === OWNER.P2 ? 'p2' : 'sys');
        span.textContent = tag === OWNER.P1 ? 'BLUE' : tag === OWNER.P2 ? 'RED' : 'SYS';
        div.appendChild(span);
        div.appendChild(document.createTextNode(text));
        ui.log.appendChild(div);
        // Keep last ~30
        const evts = ui.log.querySelectorAll('.evt');
        if (evts.length > 30) evts[0].remove();
        ui.log.scrollTop = ui.log.scrollHeight;
      }

      // --------- Map generation
      function newGame(){
        marches = [];
        selected = -1;
        dragging = false;

        const n = 16; // territories
        nodes = [];

        // Place nodes with Poisson-ish rejection to avoid overlaps
        const pad = 70;
        const minSep = 88;
        for (let i=0; i<n; i++){
          let tries = 0;
          while(true){
            tries++;
            const x = pad + rand()*(W - pad*2);
            const y = pad + rand()*(H - pad*2);
            let ok = true;
            for (const p of nodes){
              if (dist(x,y,p.x,p.y) < minSep) { ok=false; break; }
            }
            if (ok || tries > 600){
              nodes.push({
                id:i, x, y,
                owner: OWNER.NEU,
                troops: 8 + rand()*18,
                level: 1,
                heldTime: 0,
                auto: 'defend',   // 'defend' | 'send'
                autoCd: 0,
                rally: -1, // node to send to
                links: []
              });
              break;
            }
          }
        }

        // Connect with k-nearest + enforce connectivity
        const K = 2;
        for (let i=0;i<n;i++){
          const a = nodes[i];
          const dists = [];
          for (let j=0;j<n;j++){
            if (i===j) continue;
            const b = nodes[j];
            dists.push([j, dist(a.x,a.y,b.x,b.y)]);
          }
          dists.sort((x,y)=>x[1]-y[1]);
          for (let t=0;t<K;t++){
            const j = dists[t][0];
            link(i,j);
          }
        }
        // Add a few random extra edges for interesting play
        for (let k=0;k<6;k++){
          const i = (rand()*n)|0;
          const j = (rand()*n)|0;
          if (i!==j) link(i,j);
        }

        // Ensure graph connected by linking components
        connectComponents();

        // Assign starting bases
        // pick farthest pair
        let bestI=0, bestJ=1, bestD=-1;
        for (let i=0;i<n;i++){
          for (let j=i+1;j<n;j++){
            const d = dist(nodes[i].x,nodes[i].y,nodes[j].x,nodes[j].y);
            if (d>bestD){ bestD=d; bestI=i; bestJ=j; }
          }
        }
        nodes[bestI].owner = OWNER.P1;
        nodes[bestI].troops = 40 + (run.mods ? run.mods.startBonus : 0);
        nodes[bestI].level = 2;

        nodes[bestJ].owner = OWNER.P2;
        nodes[bestJ].troops = Math.floor(40 * (run.scale ? run.scale.redStartTroopsMult : 1));
        nodes[bestJ].level = 2;

        // Nearby neutrals slightly weaker to reduce stalemates
        for (const t of nodes){
          if (t.owner !== OWNER.NEU) continue;
          const d1 = dist(t.x,t.y,nodes[bestI].x,nodes[bestI].y);
          const d2 = dist(t.x,t.y,nodes[bestJ].x,nodes[bestJ].y);
          const near = Math.min(d1,d2);
          if (near < 180) t.troops *= 0.65;
        }

        logEvent(null, 'New map generated.');
        ui.badgeWin.textContent = '—';
        refreshAutoUI();
      }

      function link(i,j){
        const a = nodes[i], b = nodes[j];
        if (!a.links.includes(j)) a.links.push(j);
        if (!b.links.includes(i)) b.links.push(i);
      }

      function connectComponents(){
        const n = nodes.length;
        const comp = new Array(n).fill(-1);
        let c = 0;

        function dfs(start){
          const stack = [start];
          comp[start] = c;
          while(stack.length){
            const u = stack.pop();
            for (const v of nodes[u].links){
              if (comp[v] === -1){
                comp[v] = c;
                stack.push(v);
              }
            }
          }
        }

        for (let i=0;i<n;i++){
          if (comp[i] === -1){
            dfs(i);
            c++;
          }
        }
        if (c <= 1) return;

        // For each component, find a representative node
        const reps = [];
        for (let k=0;k<c;k++){
          let best = -1, bestScore = 1e9;
          for (let i=0;i<n;i++){
            if (comp[i] !== k) continue;
            // prefer more central
            const score = Math.abs(nodes[i].x - W/2) + Math.abs(nodes[i].y - H/2);
            if (score < bestScore){ bestScore=score; best=i; }
          }
          reps.push(best);
        }

        // Chain-connect components by nearest reps
        for (let k=0;k<reps.length-1;k++){
          const a = reps[k];
          let bestJ = -1, bestD = 1e9;
          for (let m=k+1;m<reps.length;m++){
            const b = reps[m];
            const d = dist(nodes[a].x,nodes[a].y,nodes[b].x,nodes[b].y);
            if (d < bestD){ bestD=d; bestJ=b; }
          }
          if (bestJ !== -1) link(a, bestJ);
        }
      }

      // --------- Troop generation & leveling
      function genRate(node){
		  const lvl = node.level;
		
		  if (node.owner === OWNER.NEU){
		    return GEN.baseNeutral + (lvl-1)*(GEN.levelBonus*0.35);
		  }
		
		  // base player curve
		  let base = GEN.basePlayer + (lvl-1)*GEN.levelBonus;
		
		  // apply scaling
		  if (node.owner === OWNER.P1){
		    base *= (run.mods ? run.mods.incomeMult : 1);
		  } else if (node.owner === OWNER.P2){
		    base *= (run.scale ? run.scale.redGenMult : 1);
		  }
		  return base;
		}


      function updateEconomy(dt){
        for (const n of nodes){
          // Leveling
          if (n.owner !== OWNER.NEU){
            n.heldTime += dt;
            while (n.level < GEN.maxLevel && n.heldTime >= GEN.levelUpEvery){
              n.heldTime -= GEN.levelUpEvery;
              n.level++;
              // small troop bump on level up
              n.troops += 3 + 2*(n.level-1);
              if (n.owner === OWNER.P1) logEvent(OWNER.P1, `Territory ${n.id} leveled up to Lvl: ${n.level}.`);
              if (n.owner === OWNER.P2) logEvent(OWNER.P2, `Territory ${n.id} leveled up to Lvl: ${n.level}.`);
            }
          } else {
            // neutrals don't "hold"; keep at level 1-2 slowly
            n.heldTime += dt*0.15;
            if (n.level < 2 && n.heldTime > 30){
              n.level = 2;
              n.heldTime = 0;
            }
          }

          // Generation
          n.troops += genRate(n) * dt;
          // soft cap to reduce runaway stacking
          const cap = n.level*100;
          if (n.troops > cap) n.troops = lerp(n.troops, cap, 0.01);
        }
      }

      // --------- Marches
      function spawnMarch(from, to, owner, amount){
        const a = nodes[from], b = nodes[to];
        const d = dist(a.x,a.y,b.x,b.y);
        marches.push({
          from, to, owner, amount,
          progress: 0,
          dist: d,
          fx: a.x, fy: a.y,
          tx: b.x, ty: b.y
        });
      }

      function resolveArrival(m){
        const target = nodes[m.to];
        const atkOwner = m.owner;
        const defOwner = target.owner;

        const atk = m.amount;
        const def = target.troops;

        if (atkOwner === defOwner){
          // Reinforcement
          target.troops += atk;
          return;
        }

        // Combat
        let defAdv = COMBAT.defenderAdvantage;
		if (defOwner === OWNER.P1 && run.mods) defAdv += run.mods.defBonus;
		const effectiveDef = def * defAdv;

        if (atk > effectiveDef){
          // Capture
          const remain = Math.max(COMBAT.captureFloor, atk - effectiveDef);
          const prev = target.owner;

			if (atkOwner === OWNER.P1 && prev !== OWNER.P1){
			  run.captured++;
			}

          target.owner = atkOwner;
          target.troops = remain;
          target.level = Math.max(1, Math.min(target.level, 2)); // conquest resets some infrastructure
          target.heldTime = 0;

          if (atkOwner === OWNER.P1) logEvent(OWNER.P1, `Captured territory ${target.id} from ${ownerName(prev)}.`);
          else logEvent(OWNER.P2, `Captured territory ${target.id} from ${ownerName(prev)}.`);
        } else {
          // Defense holds
          target.troops = Math.max(0, def - atk / COMBAT.defenderAdvantage);
        }
      }

      function updateMarches(dt){
        const speedBase = MOVE.speed;
        for (let i=marches.length-1; i>=0; i--){
          const m = marches[i];
          const mult = (m.owner === OWNER.P1 && run.mods) ? run.mods.speedMult : 1;
			m.progress += (speedBase * mult * dt) / m.dist;
          if (m.progress >= 1){
            resolveArrival(m);
            marches.splice(i,1);
          }
        }
      }

      // --------- Sending logic
      function canSend(from, to){
        if (from < 0 || to < 0) return false;
        return nodes[from].links.includes(to);
      }

      function sendTroops(from, to, fraction, forceAll=false){
        const src = nodes[from];
        if (!canSend(from,to)) return false;

        const total = Math.floor(src.troops);
        if (total <= MOVE.minSend) return false;

        let amount;
        if (forceAll) {
          amount = Math.max(MOVE.minSend, total - 1); // keep 1 behind
        } else {
          amount = Math.floor(total * fraction);
          amount = clamp(amount, MOVE.minSend, total - 1);
        }

        if (amount <= 0) return false;

        src.troops -= amount;
        spawnMarch(from, to, src.owner, amount);

        return true;
      }

      // --------- AI
      let aiTimer = 0;

      function aiThink(dt){
        aiTimer -= dt;
        if (aiTimer > 0) return;
        aiTimer = (run.scale ? run.scale.aiThinkEvery : AI.thinkEvery);


        // gather red nodes
        const reds = nodes.filter(n => n.owner === OWNER.P2);
        if (reds.length === 0) return;

        // choose actions per red node
        for (const src of reds){
          const srcTroops = Math.floor(src.troops);
          if (srcTroops < 10) continue;

          // evaluate neighbors
          const options = src.links.map(id => nodes[id]).filter(t => t.owner !== OWNER.P2);
          if (options.length === 0) continue;

          // priority: (1) capture weak neutrals nearby (2) punish weak blue borders (3) reinforce red under threat
          let best = null;
          let bestScore = -1e9;

          for (const t of options){
            const def = t.troops * (t.owner === OWNER.NEU ? 1.0 : COMBAT.defenderAdvantage);
            const borderThreat = estimateThreatOn(src.id, OWNER.P2); // how threatened src is by blue
            const targetValue = (t.owner === OWNER.P1 ? 1.35 : 0.85) + (t.level-1)*0.12;

            // available attackers while keeping a reserve
            const usable = Math.max(0, srcTroops - Math.floor(srcTroops * AI.reserveFrac));

            // base desirability
            let score = 0;
            score += targetValue * 10;
            score += (t.owner === OWNER.P1 ? 6 : 2);
            score += (t.troops < 18 ? 6 : 0);

            // prefer closer (fast capture)
            const d = dist(src.x,src.y,t.x,t.y);
            score += clamp(220 - d, -80, 220) / 20;

            // don't suicide into strongholds
            const margin = usable / Math.max(1, def);
            score += (margin - 1) * 18;

            // if src is threatened, be more defensive unless a great opportunity exists
            score -= borderThreat * 9;

            // slight randomness
            score += (rand()-0.5) * 4;

            // opportunistic snipe chance
            if (t.owner === OWNER.P1 && t.troops < 12 && rand() < AI.opportunism) score += 8;

            if (score > bestScore){
              bestScore = score;
              best = t;
            }
          }

          if (!best) continue;

          const defEff = best.troops * (best.owner === OWNER.NEU ? 1.0 : COMBAT.defenderAdvantage);
          const usable = Math.max(0, srcTroops - Math.floor(srcTroops * AI.reserveFrac));

          // decide attack
          const shouldAttack =
            usable > defEff * (AI.safeMargin * (run.scale ? run.scale.aiSafeMarginMult : 1)) &&
            rand() < AI.aggressiveness;

          if (shouldAttack){
            // send enough to win with a buffer
            const need = Math.ceil(defEff * AI.safeMargin + 1);
            const amt = clamp(need, MOVE.minSend, srcTroops - 1);
            // Convert to fraction for sendTroops
            const frac = amt / Math.max(1, srcTroops);
            sendTroops(src.id, best.id, frac, false);
          } else {
            // If threatened and neighbor is blue, sometimes reinforce from deeper reds (handled implicitly by inaction)
            // Or make small probing attacks into neutrals
            if (best.owner === OWNER.NEU && usable > defEff * 1.05 && rand() < 0.25){
              const need = Math.ceil(defEff * 1.08 + 1);
              const amt = clamp(need, MOVE.minSend, srcTroops - 1);
              const frac = amt / Math.max(1, srcTroops);
              sendTroops(src.id, best.id, frac, false);
            }
          }
        }
      }

      function estimateThreatOn(nodeId, owner){
        // crude border threat: sum of nearby enemy troops adjacent to node
        const n = nodes[nodeId];
        let threat = 0;
        for (const nbId of n.links){
          const nb = nodes[nbId];
          if (owner === OWNER.P2 && nb.owner === OWNER.P1) threat += nb.troops / 30;
          if (owner === OWNER.P1 && nb.owner === OWNER.P2) threat += nb.troops / 30;
        }
        return threat;
      }

      // --------- Win check + stats
      function computeStats(){
        let p1Terr=0, p2Terr=0, neuTerr=0;
        let p1Troops=0, p2Troops=0, neuTroops=0;
        let inc1=0, inc2=0;

        for (const n of nodes){
          if (n.owner === OWNER.P1){ p1Terr++; p1Troops += n.troops; inc1 += genRate(n); }
          else if (n.owner === OWNER.P2){ p2Terr++; p2Troops += n.troops; inc2 += genRate(n); }
          else { neuTerr++; neuTroops += n.troops; }
        }

        ui.statTerr.textContent = `${nodes.length} (B:${p1Terr} R:${p2Terr} N:${neuTerr})`;
        ui.statP1.textContent = fmt(p1Troops);
        ui.statP2.textContent = fmt(p2Troops);
        ui.statNeu.textContent = fmt(neuTroops);
        ui.statInc1.textContent = inc1.toFixed(2) + '/s';
        ui.statInc2.textContent = inc2.toFixed(2) + '/s';

        // win banner
        if (p1Terr === nodes.length){
          ui.badgeWin.textContent = 'Blue wins';
          ui.badgeWin.style.borderColor = COLORS.p1;
        } else if (p2Terr === nodes.length){
          ui.badgeWin.textContent = 'Red wins';
          ui.badgeWin.style.borderColor = COLORS.p2;
        } else {
          ui.badgeWin.textContent = '—';
          ui.badgeWin.style.borderColor = 'rgba(255,255,255,.12)';
        }
		  // run end detection (one-shot)
		if (!run.ended){
		  if (p1Terr === nodes.length) endRun('win');
		  else if (p2Terr === nodes.length) endRun('loss');
		}
      }

      // --------- Rendering
      function resize(){
        DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
        const rect = canvas.getBoundingClientRect();
        W = Math.max(400, rect.width);
        H = Math.max(400, rect.height);
        canvas.width = Math.floor(W * DPR);
        canvas.height = Math.floor(H * DPR);
        ctx.setTransform(DPR,0,0,DPR,0,0);

        // If no map yet, create
        if (nodes.length === 0) newGame();
      }

      function draw(){
        // background
        ctx.clearRect(0,0,W,H);

        // soft grid
        ctx.save();
        ctx.globalAlpha = 0.10;
        ctx.strokeStyle = 'rgba(255,255,255,.08)';
        ctx.lineWidth = 1;
        const step = 42;
        for (let x = 0; x < W; x += step){
          ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke();
        }
        for (let y = 0; y < H; y += step){
          ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke();
        }
        ctx.restore();

        // edges
        ctx.save();
        ctx.lineWidth = 5;
        for (const a of nodes){
          for (const j of a.links){
            if (j < a.id) continue; // draw once
            const b = nodes[j];

            // edge color blended by ownership
            const ca = ownerColor(a.owner);
            const cb = ownerColor(b.owner);

            // faint base
            ctx.strokeStyle = 'rgba(255,255,255,.10)';
            ctx.beginPath();
            ctx.moveTo(a.x, a.y);
            ctx.lineTo(b.x, b.y);
            ctx.stroke();

            // ownership gradient-ish: draw two halves
            ctx.globalAlpha = 0.70;
            ctx.strokeStyle = ca;
            ctx.beginPath();
            ctx.moveTo(a.x, a.y);
            ctx.lineTo((a.x+b.x)/2, (a.y+b.y)/2);
            ctx.stroke();

            ctx.strokeStyle = cb;
            ctx.beginPath();
            ctx.moveTo((a.x+b.x)/2, (a.y+b.y)/2);
            ctx.lineTo(b.x, b.y);
            ctx.stroke();
            ctx.globalAlpha = 1.0;
          }
        }
        ctx.restore();

        // marches (moving units)
        ctx.save();
        for (const m of marches){
          const t = clamp(m.progress, 0, 1);
          const x = lerp(m.fx, m.tx, t);
          const y = lerp(m.fy, m.ty, t);

          ctx.fillStyle = ownerColor(m.owner);
          ctx.globalAlpha = 0.95;
          ctx.beginPath();
          ctx.arc(x, y, 6, 0, Math.PI*2);
          ctx.fill();

          // trailing line
          ctx.globalAlpha = 0.35;
          ctx.strokeStyle = ownerColor(m.owner);
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.moveTo(lerp(m.fx, m.tx, Math.max(0, t-0.10)), lerp(m.fy, m.ty, Math.max(0, t-0.10)));
          ctx.lineTo(x,y);
          ctx.stroke();
          ctx.globalAlpha = 1.0;
        }
        ctx.restore();

        // drag line
        if (dragging && selected >= 0){
          const a = nodes[selected];
          ctx.save();
          ctx.strokeStyle = ownerColor(a.owner);
          ctx.lineWidth = 5;
          ctx.setLineDash([8,8]);
          ctx.globalAlpha = 0.7;
          ctx.beginPath();
          ctx.moveTo(a.x,a.y);
          ctx.lineTo(dragPos.x, dragPos.y);
          ctx.stroke();
          ctx.restore();
        }

        // nodes
        for (const n of nodes){
          const r = 22 + n.level*2.5;
          const col = ownerColor(n.owner);

          // outer glow if selected
          if (n.id === selected){
            ctx.save();
            ctx.globalAlpha = 0.25;
            ctx.fillStyle = col;
            ctx.beginPath();
            ctx.arc(n.x, n.y, r+16, 0, Math.PI*2);
            ctx.fill();
            ctx.restore();
          }

          // base
          ctx.save();
          ctx.fillStyle = 'rgba(15,23,51,.85)';
          ctx.beginPath();
          ctx.arc(n.x, n.y, r+2, 0, Math.PI*2);
          ctx.fill();

          // ring
          ctx.strokeStyle = col;
          ctx.lineWidth = 4;
          ctx.beginPath();
          ctx.arc(n.x, n.y, r, 0, Math.PI*2);
          ctx.stroke();

          // inner fill by owner
          ctx.globalAlpha = 0.2;
          ctx.fillStyle = col;
          ctx.beginPath();
          ctx.arc(n.x, n.y, r-3, 0, Math.PI*2);
          ctx.fill();
          ctx.globalAlpha = 1;

          // troops text
          ctx.fillStyle = COLORS.text;
          ctx.font = '800 13px system-ui, -apple-system, Segoe UI, Roboto, Arial';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(fmt(n.troops), n.x, n.y - 2);

          // id + level
          ctx.fillStyle = COLORS.muted;
          ctx.font = '700 10px system-ui, -apple-system, Segoe UI, Roboto, Arial';
          const mark = (n.owner === OWNER.P1 && n.auto === 'rally' && n.rally >= 0) ? `  R→#${n.rally}` : '';
          ctx.fillText(`#${n.id}  L${n.level}${mark}`, n.x, n.y + 14);


          ctx.restore();
        }
      }

      // --------- Input handling
      function toCanvasPos(evt){
        const rect = canvas.getBoundingClientRect();
        const x = (evt.clientX - rect.left);
        const y = (evt.clientY - rect.top);
        return {x,y};
      }

      function hitNode(p){
        for (let i=nodes.length-1;i>=0;i--){
          const n = nodes[i];
          const r = 26 + n.level*2.5;
          if (dist(p.x,p.y,n.x,n.y) <= r) return n.id;
        }
        return -1;
      }

      function nearestNeighbor(fromId, p){
        const from = nodes[fromId];
        let best = -1, bestD = 1e9;
        for (const j of from.links){
          const t = nodes[j];
          const d = dist(p.x,p.y,t.x,t.y);
          if (d < bestD){ bestD=d; best=j; }
        }
        return {id: best, d: bestD};
      }

      function setSelected(id){
        selected = id;
        if (id < 0){
          ui.badgeSel.textContent = 'Selected: —';
          refreshAutoUI();
          return;
        }
        const n = nodes[id];
        ui.badgeSel.textContent = `Selected: #${n.id} (${ownerName(n.owner)})`;
        refreshAutoUI();
      }


      function refreshAutoUI(){
        if (!ui.btnAuto) return;
        if (selected < 0) {
          ui.btnAuto.textContent = 'Auto: —';
          ui.btnAuto.disabled = true;
          return;
        }
        const n = nodes[selected];
        const isPlayerNode = (n.owner === OWNER.P1);
        ui.btnAuto.disabled = !isPlayerNode;
      
        if (!isPlayerNode){
          ui.btnAuto.textContent = 'Auto: —';
          return;
        }
      
        if (n.auto === 'rally'){
          const tgt = (n.rally >= 0) ? `#${n.rally}` : '—';
          ui.btnAuto.textContent = `Auto: Rally ${tgt}`;
        } else {
          ui.btnAuto.textContent = 'Auto: Defend';
        }
      }


      function nodeMoveCost(id){
        const o = nodes[id].owner;
        // prefer routing through blue, then neutral, avoid routing through red
        if (o === OWNER.P1) return 0;
        if (o === OWNER.NEU) return 1;
        return 3;
      }
      
      // Dijkstra: returns next hop from `start` toward `goal` (or -1)
      function nextHopToward(start, goal){
        if (start === goal) return -1;
      
        const N = nodes.length;
        const distArr = new Array(N).fill(Infinity);
        const prev = new Array(N).fill(-1);
        const visited = new Array(N).fill(false);
      
        distArr[start] = 0;
      
        for (let iter = 0; iter < N; iter++){
          // pick unvisited with smallest dist
          let u = -1, best = Infinity;
          for (let i=0;i<N;i++){
            if (!visited[i] && distArr[i] < best){
              best = distArr[i];
              u = i;
            }
          }
          if (u === -1) break;
          visited[u] = true;
          if (u === goal) break;
      
          for (const v of nodes[u].links){
            const alt = distArr[u] + nodeMoveCost(v);
            if (alt < distArr[v]){
              distArr[v] = alt;
              prev[v] = u;
            }
          }
        }
      
        if (prev[goal] === -1) return -1;
      
        // walk back from goal until the step right after start
        let cur = goal;
        let p = prev[cur];
        while (p !== -1 && p !== start){
          cur = p;
          p = prev[cur];
        }
        return cur; // neighbor hop from start
      }
      
    function updateRallyAuto(dt){
	  for (const n of nodes){
	    if (n.owner !== OWNER.P1) continue;
	    if (n.auto !== 'rally') continue;
	    if (n.rally < 0 || n.rally >= nodes.length) continue;
	    if (n.id === n.rally) continue;
	
	    n.autoCd -= dt;
	    if (n.autoCd > 0) continue;
	
	    const total = Math.floor(n.troops);
	    if (total < 1){
	      n.autoCd = 0.6;
	      continue;
	    }
	
	    const hop = n.links.includes(n.rally) ? n.rally : nextHopToward(n.id, n.rally);
	    if (hop === -1){
	      n.autoCd = 1.0;
	      continue;
	    }
	
	    const sent = sendTroops(n.id, hop, 0.50, false);
	    n.autoCd = sent ? (1.0 + rand()*0.8) : 0.8;
	  }
	}
	



      // Click-to-send or drag-to-send
      // no modifier: select blue
      // alt/option: set rally for selected -> clicked node (any owner), no selection changes
      // shift: send ALL from selected -> clicked neighbor (or drag neighbor), no selection changes
      let pendingDrag = false;
      let dragStart = {x:0,y:0};
      const DRAG_THRESH = 8;

      canvas.addEventListener('pointerdown', (evt) => {
        if (paused) return;
        canvas.setPointerCapture(evt.pointerId);
        const p = toCanvasPos(evt);
        dragPos = p;

        const id = hitNode(p);
        if (id === -1){
          pendingDrag = false;
          dragging = false;
          ui.badgeMode.textContent = 'Mode: Click-to-send';
          return;
        }

        const clicked = nodes[id];
        const hasSelected = (selected !== -1 && nodes[selected].owner === OWNER.P1);
        const isAlt = evt.altKey === true;
        const isShift = evt.shiftKey === true;

        // 1) Alt/Option: set rally target for selected (do not change selection)
        if (isAlt && hasSelected){
          const src = nodes[selected];
          src.rally = id;        // allow rally to friendly/neutral/enemy
          src.auto = 'rally';
          src.autoCd = 0;
          refreshAutoUI();
          logEvent(OWNER.P1, `Territory #${src.id} rally set to #${id}.`);
          return;
        }

        if (clicked.owner === OWNER.P1){
          // Alt prevents selection (reserved for rally targeting)
          if (isAlt){
            pendingDrag = false;
            dragging = false;
            return;
          }

          // Shift should NOT block dragging; it just modifies "send all" on release
          if (!isShift){
            // normal click selects
            setSelected(id);
          }
          // regardless of Shift, allow drag-start from the current selected node
          // (if nothing selected yet and Shift held, we still want to be able to drag from this node)
          if (selected === -1 || nodes[selected].owner !== OWNER.P1){
            setSelected(id);
          }

          pendingDrag = true;
          dragging = false;
          dragStart = p;
          dragPos = p;
          ui.badgeMode.textContent = 'Mode: Click-to-send';
          return;
        }


        // 3) Clicking non-blue target: if a blue node is selected, and target is neighbor, send
        if (hasSelected && canSend(selected, id)){
          const frac = Number(ui.sendPct.value) / 100;
          const forceAll = isShift; // Shift means send all
          if (sendTroops(selected, id, frac, forceAll)){
            logEvent(OWNER.P1, `Sent troops from #${selected} to #${id}.`);
          }
        }
      });

      canvas.addEventListener('pointermove', (evt) => {
        // allow drag only when we started pendingDrag from a normal selection click
        if (!pendingDrag || selected === -1) return;

        const p = toCanvasPos(evt);
        dragPos = p;

        if (!dragging){
          const dx = p.x - dragStart.x;
          const dy = p.y - dragStart.y;
          if (Math.hypot(dx,dy) >= DRAG_THRESH){
            dragging = true;
            ui.badgeMode.textContent = 'Mode: Dragging';
          }
        }
      });

      canvas.addEventListener('pointerup', (evt) => {
        if (selected === -1){
          pendingDrag = false;
          dragging = false;
          ui.badgeMode.textContent = 'Mode: Click-to-send';
          return;
        }

        // If no drag happened, we're done (click actions already handled in pointerdown)
        if (!dragging){
          pendingDrag = false;
          ui.badgeMode.textContent = 'Mode: Click-to-send';
          return;
        }

        // Drag-send: send to neighbor closest to release point (works on friendly too)
        const p = toCanvasPos(evt);
        pendingDrag = false;
        dragging = false;
        ui.badgeMode.textContent = 'Mode: Click-to-send';

        const nn = nearestNeighbor(selected, p);
        if (nn.id === -1) return;

        const target = nn.id;
        const tNode = nodes[target];
        const r = 26 + tNode.level*2.5;
        if (nn.d > r + 14) return;

        // Shift during drag release sends all; otherwise uses slider %
        const frac = Number(ui.sendPct.value) / 100;
        const forceAll = (evt.shiftKey === true);

        if (sendTroops(selected, target, frac, forceAll)){
          logEvent(OWNER.P1, `Sent troops from #${selected} to #${target}.`);
        }
      });

      // --------- UI wiring
      ui.btnNew.addEventListener('click', () => newGame());

      ui.btnPause.addEventListener('click', () => {
        paused = !paused;
        ui.btnPause.textContent = paused ? 'Resume' : 'Pause';
        logEvent(null, paused ? 'Paused.' : 'Resumed.');
      });

      ui.sendPct.addEventListener('input', () => {
        ui.sendPctPill.textContent = ui.sendPct.value + '%';
      });

      ui.speed.addEventListener('input', () => {
        timeScale = Number(ui.speed.value) / 100;
        ui.speedPill.textContent = timeScale.toFixed(2) + '×';
      });
		
		ui.btnUpg.addEventListener('click', () => {
		  ui.upgModal.classList.remove('hidden');
		  renderUpgrades();
		});
		
		ui.btnUpgClose.addEventListener('click', () => {
		  ui.upgModal.classList.add('hidden');
		});
		
		ui.upgModal.addEventListener('click', (e) => {
		  if (e.target === ui.upgModal) ui.upgModal.classList.add('hidden');
		});
		
		ui.btnRepeat.addEventListener('click', () => {
		  // repeat same wave, new random map
		  startRun({ wave: meta.wave, seed: (Date.now() ^ (Math.random()*1e9)) >>> 0 });
		  logEvent(null, `Repeated wave ${meta.wave}.`);
		});
		
		ui.btnNext.addEventListener('click', () => {
		  meta.wave++;
		  saveMeta();
		  startRun({ wave: meta.wave, seed: (Date.now() ^ (Math.random()*1e9)) >>> 0 });
		  logEvent(null, `Started wave ${meta.wave}.`);
		});

      ui.btnAuto.addEventListener('click', () => {
        if (selected < 0) return;
        const n = nodes[selected];
        if (n.owner !== OWNER.P1) return;
      
        if (n.auto === 'rally'){
          n.auto = 'defend';
        } else {
          n.auto = 'rally';
          if (n.rally === -1) {
            // if no rally target yet, keep it in rally mode but it won’t send until you alt-click a target
            logEvent(OWNER.P1, `Alt/Option-click any node to set rally for #${n.id}.`);
          }
          n.autoCd = 0;
        }
        refreshAutoUI();
      });



      window.addEventListener('resize', () => resize());

      // --------- Main loop
      function tick(now){
        const rawDt = (now - lastT) / 1000;
        lastT = now;

        const dt = clamp(rawDt, 0, 0.05) * timeScale;

        if (!paused){
			run.seconds += dt;
          updateEconomy(dt);
          updateMarches(dt);
          updateRallyAuto(dt);
          aiThink(dt);
          computeStats();
        }

        draw();
        requestAnimationFrame(tick);
      }

      // init
		loadMeta();
		refreshMetaUI();
      resize();
		startRun({ wave: meta.wave, seed: (Date.now() ^ (Math.random()*1e9)) >>> 0 });
      ui.sendPct.dispatchEvent(new Event('input'));
      ui.speed.dispatchEvent(new Event('input'));
      computeStats();
      logEvent(null, 'Click a blue territory to start. Shift sends all. Alt sets rally target. Win to earn credits.');

      requestAnimationFrame(tick);
    })();
  </script>
</body>
</html>
